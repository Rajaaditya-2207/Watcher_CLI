import { WatcherDatabase, ChangeRow } from '../database/Database';
import path from 'path';
import fs from 'fs';

export class ChangelogGenerator {
    private db: WatcherDatabase;
    private projectPath: string;

    constructor(db: WatcherDatabase, projectPath: string) {
        this.db = db;
        this.projectPath = projectPath;
    }

    async generate(): Promise<string> {
        const projectId = this.db.getProjectId(this.projectPath);
        if (projectId === null) {
            throw new Error('Project ID not found.');
        }

        const changes = this.db.getChanges(projectId);

        let content = '';

        // Header
        content += `# Changelog\n\n`;
        content += `All notable changes to this project are documented automatically by Watcher.\n\n`;

        if (changes.length === 0) {
            content += `No changes recorded yet.\n`;
        } else {
            const grouped = this.groupByDate(changes);

            for (const [date, dateChanges] of Object.entries(grouped)) {
                content += `## ${date}\n\n`;

                // Group by category within each date
                const features = dateChanges.filter((c) => c.category === 'feature');
                const fixes = dateChanges.filter((c) => c.category === 'fix');
                const refactors = dateChanges.filter((c) => c.category === 'refactor');
                const docs = dateChanges.filter((c) => c.category === 'docs');
                const styles = dateChanges.filter((c) => c.category === 'style');
                const tests = dateChanges.filter((c) => c.category === 'test');
                const other = dateChanges.filter(
                    (c) => !['feature', 'fix', 'refactor', 'docs', 'style', 'test'].includes(c.category)
                );

                if (features.length > 0) {
                    content += `### Features\n\n`;
                    for (const change of features) {
                        content += `- ${change.summary}\n`;
                    }
                    content += `\n`;
                }

                if (fixes.length > 0) {
                    content += `### Fixes\n\n`;
                    for (const change of fixes) {
                        content += `- ${change.summary}\n`;
                    }
                    content += `\n`;
                }

                if (refactors.length > 0) {
                    content += `### Refactors\n\n`;
                    for (const change of refactors) {
                        content += `- ${change.summary}\n`;
                    }
                    content += `\n`;
                }

                if (docs.length > 0) {
                    content += `### Documentation\n\n`;
                    for (const change of docs) {
                        content += `- ${change.summary}\n`;
                    }
                    content += `\n`;
                }

                if (styles.length > 0) {
                    content += `### Style\n\n`;
                    for (const change of styles) {
                        content += `- ${change.summary}\n`;
                    }
                    content += `\n`;
                }

                if (tests.length > 0) {
                    content += `### Tests\n\n`;
                    for (const change of tests) {
                        content += `- ${change.summary}\n`;
                    }
                    content += `\n`;
                }

                if (other.length > 0) {
                    content += `### Other\n\n`;
                    for (const change of other) {
                        content += `- ${change.summary}\n`;
                    }
                    content += `\n`;
                }
            }
        }

        content += `---\n*Generated by Watcher CLI*\n`;

        // Write to file
        const outputPath = path.join(this.projectPath, 'CHANGELOG.md');
        fs.writeFileSync(outputPath, content, 'utf-8');

        return content;
    }

    private groupByDate(changes: ChangeRow[]): Record<string, ChangeRow[]> {
        const grouped: Record<string, ChangeRow[]> = {};

        for (const change of changes) {
            const date = change.timestamp.split(' ')[0] || change.timestamp.split('T')[0] || 'Unknown';
            if (!grouped[date]) {
                grouped[date] = [];
            }
            grouped[date].push(change);
        }

        return grouped;
    }
}
