import { WatcherDatabase, ChangeRow } from '../database/Database';
import path from 'path';
import fs from 'fs';

export class ProgressGenerator {
    private db: WatcherDatabase;
    private projectPath: string;

    constructor(db: WatcherDatabase, projectPath: string) {
        this.db = db;
        this.projectPath = projectPath;
    }

    async generate(): Promise<string> {
        const project = this.db.getProject(this.projectPath);
        if (!project) {
            throw new Error('Project not found in database.');
        }

        const projectId = this.db.getProjectId(this.projectPath);
        if (projectId === null) {
            throw new Error('Project ID not found.');
        }

        const changes = this.db.getChanges(projectId, undefined, 50);
        const summary = this.db.getChangeSummary(projectId);

        let content = '';

        // Header
        content += `# Project Progress\n\n`;

        // Overview
        content += `## Overview\n\n`;
        content += `**Project:** ${project.name}\n`;
        content += `**Path:** ${project.path}\n`;
        content += `**Architecture:** ${project.architecture}\n`;
        if (project.techStack.length > 0) {
            content += `**Tech Stack:** ${project.techStack.join(', ')}\n`;
        }
        content += `**Last Updated:** ${new Date().toISOString().split('T')[0]}\n\n`;

        // Summary Statistics
        content += `## Summary\n\n`;
        content += `| Metric | Value |\n`;
        content += `|--------|-------|\n`;
        content += `| Total Changes | ${summary.totalChanges} |\n`;
        content += `| Lines Added | +${summary.totalLinesAdded} |\n`;
        content += `| Lines Removed | -${summary.totalLinesRemoved} |\n`;

        if (Object.keys(summary.categories).length > 0) {
            content += `\n### Change Categories\n\n`;
            content += `| Category | Count |\n`;
            content += `|----------|-------|\n`;
            for (const [category, count] of Object.entries(summary.categories)) {
                content += `| ${category} | ${count} |\n`;
            }
        }
        content += `\n`;

        // Recent Changes
        if (changes.length > 0) {
            content += `## Recent Changes\n\n`;

            const grouped = this.groupByDate(changes);
            for (const [date, dateChanges] of Object.entries(grouped)) {
                content += `### ${date}\n\n`;
                for (const change of dateChanges) {
                    content += `- **[${change.category.toUpperCase()}]** ${change.summary}`;
                    if (change.impact !== 'low') {
                        content += ` *(${change.impact} impact)*`;
                    }
                    content += `\n`;
                    if (change.description) {
                        content += `  ${change.description.substring(0, 200)}\n`;
                    }
                }
                content += `\n`;
            }
        } else {
            content += `## Recent Changes\n\nNo changes recorded yet.\n\n`;
        }

        // Current Status
        content += `## Status\n\n`;
        if (summary.totalChanges > 0) {
            const featureCount = summary.categories['feature'] || 0;
            const fixCount = summary.categories['fix'] || 0;
            const refactorCount = summary.categories['refactor'] || 0;

            if (featureCount > 0) content += `- Features implemented: ${featureCount}\n`;
            if (fixCount > 0) content += `- Bug fixes applied: ${fixCount}\n`;
            if (refactorCount > 0) content += `- Refactors completed: ${refactorCount}\n`;
        } else {
            content += `Project initialized. No changes recorded yet.\n`;
        }

        content += `\n---\n*Generated by Watcher CLI*\n`;

        // Write to file
        const outputPath = path.join(this.projectPath, 'PROGRESS.md');
        fs.writeFileSync(outputPath, content, 'utf-8');

        return content;
    }

    private groupByDate(changes: ChangeRow[]): Record<string, ChangeRow[]> {
        const grouped: Record<string, ChangeRow[]> = {};

        for (const change of changes) {
            const date = change.timestamp.split(' ')[0] || change.timestamp.split('T')[0] || 'Unknown';
            if (!grouped[date]) {
                grouped[date] = [];
            }
            grouped[date].push(change);
        }

        return grouped;
    }
}
